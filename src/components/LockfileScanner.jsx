import React, { useState, useMemo } from 'react'
import { IconUpload, IconFile, IconX } from '@tabler/icons-react'

const parsePackageLock = (content) => {
  try {
    const lockfile = JSON.parse(content)
    const packages = new Map()
    const lockfileVersion = lockfile.lockfileVersion || 0

    const addPackage = (name, version) => {
      if (name && version && !name.startsWith('node_modules/')) {
        const key = `${name.toLowerCase()}@${version}`
        packages.set(key, { name: name.toLowerCase(), version })
      }
    }

    if (lockfile.packages) {
      Object.keys(lockfile.packages).forEach((path) => {
        if (path === '') return
        const pkg = lockfile.packages[path]
        const name = path.substring(path.lastIndexOf('node_modules/') + 'node_modules/'.length)
        if (pkg.version && !pkg.dev) addPackage(name, pkg.version)
      })
    } else if (lockfile.dependencies) {
      const parseV1Deps = (deps) => {
        Object.keys(deps).forEach((name) => {
          const pkg = deps[name]
          if (pkg.version && !pkg.dev) {
            addPackage(name, pkg.version)
            if (pkg.dependencies) parseV1Deps(pkg.dependencies)
          }
        })
      }
      parseV1Deps(lockfile.dependencies)
    }

    if (!packages.size) return { error: 'No packages found. Is this a valid package-lock.json?' }
    return { type: `npm lockfile v${lockfileVersion}`, packages: Array.from(packages.values()) }
  } catch (e) {
    return { error: `JSON parse error: ${e.message}` }
  }
}

const parseYarnLock = (content) => {
  if (content.includes('__metadata:')) {
    return { error: 'Yarn Berry lockfile (v2+) detected. Support is limited.', isWarning: true }
  }
  try {
    const packages = new Map()
    const lines = content.split(/\r?\n/)
    let current = []

    for (const line of lines) {
      if (!line.startsWith(' ')) {
        if (line.trim() === '' || line.startsWith('#')) {
          current = []
          continue
        }
        current = line.split(',').map((name) => name.trim().replace(/^"|"$|:$/g, '').split('@')[0])
      } else if (line.trim().startsWith('version "')) {
        const version = line.trim().match(/version "([^"]+)"/)?.[1]
        if (version && current.length) {
          current.forEach((name) => {
            const key = `${name.toLowerCase()}@${version}`
            packages.set(key, { name: name.toLowerCase(), version })
          })
        }
      }
    }
    if (!packages.size) return { error: 'Could not parse packages. Is this a valid yarn.lock v1 file?' }
    return { type: 'Yarn Classic v1', packages: Array.from(packages.values()) }
  } catch (e) {
    return { error: `Yarn parse error: ${e.message}` }
  }
}

const parsePnpmLock = (content) => {
  try {
    const packages = new Map()
    const lines = content.split(/\r?\n/)

    for (const line of lines) {
      const trimmed = line.trim()
      if (trimmed.startsWith('/') && trimmed.endsWith(':')) {
        const match = trimmed.match(/^\/(.+)\/([^/]+):$/)
        if (match) {
          const name = match[1]
          let version = match[2]
          if (version.includes('_')) version = version.split('_')[0]
          const key = `${name.toLowerCase()}@${version}`
          packages.set(key, { name: name.toLowerCase(), version })
        }
      }
    }
    if (!packages.size) return { error: 'No packages found. Is this a valid pnpm-lock.yaml file?' }
    return { type: 'pnpm lockfile', packages: Array.from(packages.values()) }
  } catch (e) {
    return { error: `pnpm parse error: ${e.message}` }
  }
}

const detectAndParseLockfile = (content) => {
  if (!content) return null
  if (content.includes('lockfileVersion')) return parsePackageLock(content)
  if (content.includes('pnpm-lock.yaml')) return parsePnpmLock(content)
  if (content.includes('# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.')) return parseYarnLock(content)
  const jsonAttempt = parsePackageLock(content)
  if (!jsonAttempt.error) return jsonAttempt
  const pnpmAttempt = parsePnpmLock(content)
  if (!pnpmAttempt.error) return pnpmAttempt
  const yarnAttempt = parseYarnLock(content)
  if (!yarnAttempt.error || yarnAttempt.isWarning) return yarnAttempt
  return { error: 'Could not determine lockfile type. Please provide a valid package-lock.json, yarn.lock, or pnpm-lock.yaml.' }
}

const OSV_API_BATCH_URL = 'https://api.osv.dev/v1/querybatch'
const BATCH_SIZE = 500

const queryOsv = async (packages, onProgress) => {
  const chunks = []
  for (let i = 0; i < packages.length; i += BATCH_SIZE) {
    chunks.push(packages.slice(i, i + BATCH_SIZE))
  }

  let all = []
  for (let i = 0; i < chunks.length; i++) {
    const chunk = chunks[i]
    onProgress({ current: i + 1, total: chunks.length })
    try {
      const queries = chunk.map((pkg) => ({
        package: { name: pkg.name, ecosystem: 'npm' },
        version: pkg.version,
      }))
      const resp = await fetch(OSV_API_BATCH_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ queries }),
      })
      if (!resp.ok) throw new Error(`OSV API request failed with status ${resp.status}`)
      const data = await resp.json()
      const chunkResults = chunk.map((pkg, idx) => {
        const res = data.results[idx]
        return {
          ...pkg,
          status: res?.vulns?.length > 0 ? 'Affected' : 'Not affected',
          vulns: res?.vulns || [],
          error: null,
        }
      })
      all = all.concat(chunkResults)
    } catch (e) {
      const errs = chunk.map((pkg) => ({
        ...pkg,
        status: 'Unknown',
        vulns: [],
        error: e.message,
      }))
      all = all.concat(errs)
    }
  }
  return all
}

function InputArea({ setLockfileContent, setFileName, fileName }) {
  const [inputType, setInputType] = useState('paste')
  const [isDragging, setIsDragging] = useState(false)

  const handleFile = (file) => {
    if (!file) return
    setFileName(file.name)
    const reader = new FileReader()
    reader.onload = (e) => setLockfileContent(e.target.result)
    reader.readAsText(file)
  }

  const onDrop = (e) => {
    e.preventDefault()
    setIsDragging(false)
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFile(e.dataTransfer.files[0])
      e.dataTransfer.clearData()
    }
  }

  const onDragOver = (e) => {
    e.preventDefault()
    setIsDragging(true)
  }

  const onDragLeave = (e) => {
    e.preventDefault()
    setIsDragging(false)
  }

  return (
    <div className="bg-white border-2 border-black rounded-xl shadow-md p-4">
      <div className="flex border-b-2 border-black mb-4">
        <button
          onClick={() => setInputType('paste')}
          className={
            inputType === 'paste'
              ? 'px-4 py-2 -mb-px font-medium border-b-2 border-black'
              : 'px-4 py-2 -mb-px font-medium text-gray-600'
          }
        >
          Paste Text
        </button>
        <button
          onClick={() => setInputType('upload')}
          className={
            inputType === 'upload'
              ? 'px-4 py-2 -mb-px font-medium border-b-2 border-black'
              : 'px-4 py-2 -mb-px font-medium text-gray-600'
          }
        >
          Upload File
        </button>
      </div>
      {inputType === 'paste' ? (
        <textarea
          className="w-full h-48 p-3 font-mono text-sm bg-white border-2 border-black rounded-lg focus:outline-none"
          placeholder="Paste lockfile content here..."
          onChange={(e) => {
            setLockfileContent(e.target.value)
            setFileName('')
          }}
        />
      ) : (
        <div
          onDrop={onDrop}
          onDragOver={onDragOver}
          onDragLeave={onDragLeave}
          className={
            isDragging
              ? 'relative w-full h-48 p-3 border-2 border-dashed border-black rounded-lg flex flex-col items-center justify-center bg-gray-100'
              : 'relative w-full h-48 p-3 border-2 border-dashed border-black rounded-lg flex flex-col items-center justify-center'
          }
        >
          <IconUpload className="h-6 w-6 text-gray-600" />
          <p className="mt-2 text-gray-600">
            {fileName ? (
              <span className="flex items-center bg-gray-100 p-2 rounded-lg">
                <IconFile className="h-5 w-5 mr-2" /> {fileName}
              </span>
            ) : (
              'Drag & drop a file or click to select'
            )}
          </p>
          <input
            type="file"
            className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
            onChange={(e) => handleFile(e.target.files[0])}
            accept=".json,.lock,.yaml"
          />
        </div>
      )}
    </div>
  )
}

function ResultsTable({ results, filterText, setFilterText }) {
  const filtered = useMemo(() => {
    if (!filterText) return results
    const q = filterText.toLowerCase()
    return results.filter(
      (item) =>
        item.name.toLowerCase().includes(q) ||
        item.version.toLowerCase().includes(q) ||
        item.status.toLowerCase().includes(q) ||
        item.vulns.some((v) => v.id.toLowerCase().includes(q)),
    )
  }, [results, filterText])

  const exportCsv = () => {
    const headers = ['Package', 'Version', 'Status', 'Advisories']
    const rows = filtered.map((item) => [
      item.name,
      item.version,
      item.status,
      item.vulns.map((v) => v.id).join(' '),
    ])
    const csv = [headers.join(','), ...rows.map((r) => r.join(','))].join('\n')
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' })
    const link = document.createElement('a')
    link.href = URL.createObjectURL(blob)
    link.download = 'lockfile-scan-results.csv'
    link.click()
    URL.revokeObjectURL(link.href)
  }

  if (!filtered.length) return <p className="mt-4 text-sm text-gray-600">No results.</p>

  return (
    <div className="mt-4">
      <div className="flex items-center justify-between mb-2">
        <input
          type="text"
          placeholder="Filter results..."
          className="w-1/2 p-2 bg-white border-2 border-black rounded-lg text-sm"
          value={filterText}
          onChange={(e) => setFilterText(e.target.value)}
        />
        <button
          onClick={exportCsv}
          className="bg-white border-2 border-black text-black rounded-lg px-3 py-1 text-sm hover:bg-gray-100"
        >
          Export CSV
        </button>
      </div>
      <div className="overflow-x-auto">
        <table className="min-w-full text-sm border-2 border-black rounded-lg">
          <thead className="bg-gray-100">
            <tr>
              <th className="px-4 py-2 text-left border-b-2 border-black">Package</th>
              <th className="px-4 py-2 text-left border-b-2 border-black">Version</th>
              <th className="px-4 py-2 text-left border-b-2 border-black">Status</th>
              <th className="px-4 py-2 text-left border-b-2 border-black">Advisories</th>
            </tr>
          </thead>
          <tbody>
            {filtered.map((item, idx) => (
              <tr key={idx} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>
                <td className="px-4 py-2 font-mono">{item.name}</td>
                <td className="px-4 py-2 font-mono">{item.version}</td>
                <td className="px-4 py-2">
                  <span className="px-2 py-1 text-xs font-semibold rounded bg-gray-200 text-gray-800">
                    {item.status}
                  </span>
                </td>
                <td className="px-4 py-2 space-x-1">
                  {item.vulns.length > 0 ? (
                    item.vulns.map((v) => (
                      <a
                        key={v.id}
                        href={`https://osv.dev/vulnerability/${v.id}`}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="underline text-gray-800"
                      >
                        {v.id}
                      </a>
                    ))
                  ) : (
                    <span>-</span>
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}

export default function LockfileScanner() {
  const [lockfileContent, setLockfileContent] = useState('')
  const [fileName, setFileName] = useState('')
  const [results, setResults] = useState([])
  const [error, setError] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [filter, setFilter] = useState('')
  const [progress, setProgress] = useState({ current: 0, total: 0 })

  const handleScan = async () => {
    setError('')
    setResults([])
    const parsed = detectAndParseLockfile(lockfileContent)
    if (!parsed || parsed.error) {
      setError(parsed?.error || 'Could not parse lockfile.')
      return
    }
    setIsLoading(true)
    try {
      const res = await queryOsv(parsed.packages, setProgress)
      setResults(res)
    } catch (e) {
      setError(e.message)
    }
    setIsLoading(false)
  }

  return (
    <div className="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
      <h1 className="text-3xl font-bold mb-2">JavaScript Lockfile Scanner</h1>
      <p className="text-gray-600 mb-4">
        Paste or upload a lockfile to check for known vulnerabilities. Only package names and versions are sent to OSV.dev.
      </p>
      <InputArea
        setLockfileContent={setLockfileContent}
        setFileName={setFileName}
        fileName={fileName}
      />
      <div className="mt-4 flex items-center gap-2">
        <button
          onClick={handleScan}
          className="bg-black text-white rounded-lg px-4 py-2 hover:bg-gray-800 focus:ring-2 focus:ring-black"
          disabled={isLoading || !lockfileContent}
        >
          {isLoading ? 'Scanning...' : 'Scan'}
        </button>
        {isLoading && (
          <span className="text-sm text-gray-600">
            Batch {progress.current} of {progress.total}
          </span>
        )}
      </div>
      {error && (
        <div className="mt-4 p-3 bg-gray-200 text-black rounded-lg flex items-center justify-between">
          <span>{error}</span>
          <button onClick={() => setError('')} className="ml-2">
            <IconX className="h-4 w-4" />
          </button>
        </div>
      )}
      {results.length > 0 && (
        <ResultsTable results={results} filterText={filter} setFilterText={setFilter} />
      )}
    </div>
  )
}

